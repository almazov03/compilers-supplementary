-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Expr;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
  x=lident  {Var (x)}               |
  inbr[s("("), exp, s(")")]);

var exp = memo $ eta expr({[Left, {[s("!!"), fun (l, op, r) {Binop(op, l, r)}]}],
  [Left, {[s("&&"), fun (l, op, r) {Binop (op, l, r)}]}],

  [Nona, {[s("=="), fun (l, op, r) {Binop(op, l, r)}],
    [s("!="), fun (l, op, r) {Binop(op, l, r)}],
    [s("<"),  fun (l, op, r) {Binop(op, l, r)}],
    [s("<="), fun (l, op, r) {Binop(op, l, r)}],
    [s(">"),  fun (l, op, r) {Binop(op, l, r)}],
    [s(">="), fun (l, op, r) {Binop(op, l, r)}]}],

  [Left, {[s("+"),  fun (l, op, r) {Binop(op, l, r)}],
    [s("-"),  fun (l, op, r) {Binop(op, l, r)}]}],

  [Left, {[s("*"),  fun (l, op, r) {Binop(op, l, r)}],
    [s("/"),  fun (l, op, r) {Binop(op, l, r)}],
    [s("%"),  fun (l, op, r) {Binop(op, l, r)}]}]}, primary);

var simple_stmt = memo $ eta syntax (kRead x=inbr[s("("), lident, s(")")] {Read (x)} |
  kSkip {Skip}                                    |
  kWrite x=inbr[s("("), exp, s(")")] {Write(x)}   |
  x=lident s[":="] e=exp {Assn(x, e)});

var stmt = memo $ eta syntax (simple_stmt | a=simple_stmt s[";"] b=stmt {Seq(a, b)});


-- Public top-level parser
public parse = stmt;

